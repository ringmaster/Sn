package sn

import (
	"regexp"
	"strings"
	"testing"
	"time"

	"github.com/spf13/afero"
	"github.com/spf13/viper"
)

// TestConvertItemToBlogPost tests the conversion of Item to BlogPost
// This verifies the actual business logic of converting internal items
// to ActivityPub format
func TestConvertItemToBlogPost(t *testing.T) {
	// Setup: ActivityPub must be enabled for conversion to work
	viper.Reset()
	viper.Set("activitypub.enabled", true)
	viper.Set("rooturl", "https://example.com/")

	now := time.Now()
	item := Item{
		Title:      "Test Post Title",
		Slug:       "test-post",
		Repo:       "blog",
		Date:       now,
		Categories: []string{"golang", "testing"},
		Authors:    []string{"alice", "bob"},
		Html:       "<p>This is the post content.</p>",
		Raw:        "This is the post content.",
		Frontmatter: map[string]string{
			"summary": "A test post about testing",
		},
	}

	blogPost := ConvertItemToBlogPost(item)

	// Verify conversion happened
	if blogPost == nil {
		t.Fatal("ConvertItemToBlogPost should return a BlogPost when ActivityPub is enabled")
	}

	// Verify all fields are correctly mapped
	if blogPost.Title != item.Title {
		t.Errorf("Title mismatch: got %q, want %q", blogPost.Title, item.Title)
	}

	if blogPost.Slug != item.Slug {
		t.Errorf("Slug mismatch: got %q, want %q", blogPost.Slug, item.Slug)
	}

	if blogPost.HTMLContent != item.Html {
		t.Errorf("HTMLContent mismatch: got %q, want %q", blogPost.HTMLContent, item.Html)
	}

	if blogPost.MarkdownContent != item.Raw {
		t.Errorf("MarkdownContent mismatch: got %q, want %q", blogPost.MarkdownContent, item.Raw)
	}

	// Verify summary is taken from frontmatter
	if blogPost.Summary != "A test post about testing" {
		t.Errorf("Summary should come from frontmatter: got %q", blogPost.Summary)
	}

	// Verify URL is correctly formed
	expectedURL := "https://example.com/posts/test-post"
	if blogPost.URL != expectedURL {
		t.Errorf("URL mismatch: got %q, want %q", blogPost.URL, expectedURL)
	}

	// Verify tags are mapped from categories
	if len(blogPost.Tags) != 2 {
		t.Errorf("Tags count mismatch: got %d, want 2", len(blogPost.Tags))
	}

	// Verify authors are passed through
	if len(blogPost.Authors) != 2 {
		t.Errorf("Authors count mismatch: got %d, want 2", len(blogPost.Authors))
	}
}

func TestConvertItemToBlogPost_WithDescription(t *testing.T) {
	viper.Reset()
	viper.Set("activitypub.enabled", true)
	viper.Set("rooturl", "https://example.com/")

	item := Item{
		Title: "Test Post",
		Slug:  "test",
		Repo:  "blog",
		Date:  time.Now(),
		Frontmatter: map[string]string{
			"description": "This is the description",
		},
	}

	blogPost := ConvertItemToBlogPost(item)

	// When no summary but description exists, description should be used
	if blogPost.Summary != "This is the description" {
		t.Errorf("Summary should fall back to description: got %q", blogPost.Summary)
	}
}

func TestConvertItemToBlogPost_AutoGeneratedSummary(t *testing.T) {
	viper.Reset()
	viper.Set("activitypub.enabled", true)
	viper.Set("rooturl", "https://example.com/")

	item := Item{
		Title:       "Test Post",
		Slug:        "test",
		Repo:        "blog",
		Date:        time.Now(),
		Html:        "<p>First sentence here. Second sentence follows.</p>",
		Frontmatter: map[string]string{}, // No summary or description
	}

	blogPost := ConvertItemToBlogPost(item)

	// When no summary or description, should auto-generate from HTML
	if blogPost.Summary == "" {
		t.Error("Summary should be auto-generated from HTML content")
	}
}

func TestConvertItemToBlogPost_ActivityPubDisabled(t *testing.T) {
	viper.Reset()
	viper.Set("activitypub.enabled", false)

	item := Item{
		Title: "Test Post",
		Slug:  "test",
		Repo:  "blog",
	}

	blogPost := ConvertItemToBlogPost(item)

	// When ActivityPub is disabled, should return nil
	if blogPost != nil {
		t.Error("ConvertItemToBlogPost should return nil when ActivityPub is disabled")
	}
}

func TestConvertItemToBlogPost_RepoSpecificActivityPub(t *testing.T) {
	viper.Reset()
	viper.Set("activitypub.enabled", true)
	viper.Set("repos.private.activitypub", false) // Disable for specific repo
	viper.Set("rooturl", "https://example.com/")

	item := Item{
		Title: "Private Post",
		Slug:  "private-post",
		Repo:  "private",
	}

	blogPost := ConvertItemToBlogPost(item)

	// When repo has ActivityPub disabled, should return nil
	if blogPost != nil {
		t.Error("ConvertItemToBlogPost should return nil for repos with ActivityPub disabled")
	}
}

func TestConvertItemToBlogPost_CustomRootURL(t *testing.T) {
	viper.Reset()
	viper.Set("activitypub.enabled", true)
	viper.Set("rooturl", "https://example.com/")
	viper.Set("activitypub.rooturl", "https://activitypub.example.com")

	item := Item{
		Title: "Test Post",
		Slug:  "test",
		Repo:  "blog",
	}

	blogPost := ConvertItemToBlogPost(item)

	// Should use activitypub.rooturl when set
	expectedURL := "https://activitypub.example.com/posts/test"
	if blogPost.URL != expectedURL {
		t.Errorf("URL should use activitypub.rooturl: got %q, want %q", blogPost.URL, expectedURL)
	}
}

// TestItemStruct verifies the Item struct can be properly instantiated
// with all its fields
func TestItemStruct(t *testing.T) {
	now := time.Now()
	item := Item{
		Title:       "My Post",
		Slug:        "my-post",
		Repo:        "blog",
		Date:        now,
		Categories:  []string{"tech"},
		Authors:     []string{"author1"},
		Frontmatter: map[string]string{"key": "value"},
		RawDate:     "2024-01-01",
		Raw:         "# My Post",
		Html:        "<h1>My Post</h1>",
		Source:      "/path/to/file.md",
		Id:          123,
	}

	// Verify all fields are set correctly
	if item.Title != "My Post" {
		t.Error("Item.Title not set correctly")
	}
	if item.Id != 123 {
		t.Error("Item.Id not set correctly")
	}
	if len(item.Categories) != 1 || item.Categories[0] != "tech" {
		t.Error("Item.Categories not set correctly")
	}
}

// TestItemResultStruct verifies pagination fields work correctly
func TestItemResultStruct(t *testing.T) {
	result := ItemResult{
		Items:    []Item{{Title: "Post 1"}, {Title: "Post 2"}},
		Total:    50,
		Paginate: 10,
		Pages:    5,
		Page:     2,
	}

	if len(result.Items) != 2 {
		t.Errorf("ItemResult.Items should have 2 items, got %d", len(result.Items))
	}
	if result.Total != 50 {
		t.Errorf("ItemResult.Total should be 50, got %d", result.Total)
	}
	if result.Pages != 5 {
		t.Errorf("ItemResult.Pages should be 5, got %d", result.Pages)
	}
}

// TestCompareFileStates verifies the file change detection logic
func TestCompareFileStates(t *testing.T) {
	baseTime := time.Now()
	laterTime := baseTime.Add(time.Hour)

	tests := []struct {
		name          string
		prev          map[string]FileState
		curr          map[string]FileState
		expectedCount int
		expectedFiles []string
	}{
		{
			name:          "no changes",
			prev:          map[string]FileState{"file1.md": {Path: "file1.md", ModTime: baseTime}},
			curr:          map[string]FileState{"file1.md": {Path: "file1.md", ModTime: baseTime}},
			expectedCount: 0,
			expectedFiles: []string{},
		},
		{
			name:          "modified file",
			prev:          map[string]FileState{"file1.md": {Path: "file1.md", ModTime: baseTime}},
			curr:          map[string]FileState{"file1.md": {Path: "file1.md", ModTime: laterTime}},
			expectedCount: 1,
			expectedFiles: []string{"file1.md"},
		},
		{
			name:          "new file",
			prev:          map[string]FileState{},
			curr:          map[string]FileState{"file1.md": {Path: "file1.md", ModTime: baseTime}},
			expectedCount: 1,
			expectedFiles: []string{"file1.md"},
		},
		{
			name:          "deleted file",
			prev:          map[string]FileState{"file1.md": {Path: "file1.md", ModTime: baseTime}},
			curr:          map[string]FileState{},
			expectedCount: 1,
			expectedFiles: []string{"file1.md"},
		},
		{
			name: "multiple changes",
			prev: map[string]FileState{
				"file1.md": {Path: "file1.md", ModTime: baseTime},
				"file2.md": {Path: "file2.md", ModTime: baseTime},
				"file3.md": {Path: "file3.md", ModTime: baseTime},
			},
			curr: map[string]FileState{
				"file1.md": {Path: "file1.md", ModTime: laterTime}, // modified
				"file2.md": {Path: "file2.md", ModTime: baseTime},  // unchanged
				// file3.md deleted
				"file4.md": {Path: "file4.md", ModTime: baseTime}, // new
			},
			expectedCount: 3, // modified + deleted + new
			expectedFiles: []string{"file1.md", "file3.md", "file4.md"},
		},
		{
			name:          "both empty",
			prev:          map[string]FileState{},
			curr:          map[string]FileState{},
			expectedCount: 0,
			expectedFiles: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := CompareFileStates(tt.prev, tt.curr)

			if len(result) != tt.expectedCount {
				t.Errorf("CompareFileStates returned %d changes, want %d", len(result), tt.expectedCount)
			}

			// Verify expected files are in the result
			for _, expectedFile := range tt.expectedFiles {
				found := false
				for _, f := range result {
					if f == expectedFile {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("Expected file %q not found in result %v", expectedFile, result)
				}
			}
		})
	}
}

// TestFileStateStruct verifies FileState struct fields
func TestFileStateStruct(t *testing.T) {
	now := time.Now()
	fs := FileState{
		Path:    "/path/to/file.md",
		ModTime: now,
	}

	if fs.Path != "/path/to/file.md" {
		t.Errorf("FileState.Path = %q, want /path/to/file.md", fs.Path)
	}
	if !fs.ModTime.Equal(now) {
		t.Error("FileState.ModTime not set correctly")
	}
}

// TestGetFileStates verifies file scanning with regex filtering
func TestGetFileStates(t *testing.T) {
	// Create an in-memory filesystem
	memFs := afero.NewMemMapFs()

	// Create test directory structure
	afero.WriteFile(memFs, "/content/post1.md", []byte("# Post 1"), 0644)
	afero.WriteFile(memFs, "/content/post2.md", []byte("# Post 2"), 0644)
	afero.WriteFile(memFs, "/content/image.png", []byte("binary"), 0644)
	afero.WriteFile(memFs, "/content/subdir/post3.md", []byte("# Post 3"), 0644)
	afero.WriteFile(memFs, "/content/subdir/readme.txt", []byte("readme"), 0644)

	tests := []struct {
		name          string
		dir           string
		filter        *regexp.Regexp
		expectedCount int
		expectedPaths []string
	}{
		{
			name:          "match markdown files",
			dir:           "/content",
			filter:        regexp.MustCompile(`\.md$`),
			expectedCount: 3,
			expectedPaths: []string{"/content/post1.md", "/content/post2.md", "/content/subdir/post3.md"},
		},
		{
			name:          "match txt files",
			dir:           "/content",
			filter:        regexp.MustCompile(`\.txt$`),
			expectedCount: 1,
			expectedPaths: []string{"/content/subdir/readme.txt"},
		},
		{
			name:          "match all files",
			dir:           "/content",
			filter:        regexp.MustCompile(`.*`),
			expectedCount: 5,
			expectedPaths: []string{"/content/post1.md", "/content/post2.md", "/content/image.png"},
		},
		{
			name:          "match nothing",
			dir:           "/content",
			filter:        regexp.MustCompile(`\.xyz$`),
			expectedCount: 0,
			expectedPaths: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := GetFileStates(memFs, tt.dir, tt.filter)

			if err != nil {
				t.Errorf("GetFileStates returned error: %v", err)
				return
			}

			if len(result) != tt.expectedCount {
				t.Errorf("GetFileStates returned %d files, want %d", len(result), tt.expectedCount)
			}

			// Verify expected files are in results
			for _, expectedPath := range tt.expectedPaths {
				if _, ok := result[expectedPath]; !ok {
					t.Errorf("Expected path %q not found in results", expectedPath)
				}
			}
		})
	}
}

// TestLoadItem verifies markdown parsing and frontmatter extraction
func TestLoadItem(t *testing.T) {
	// Create an in-memory filesystem
	memFs := afero.NewMemMapFs()

	// Save the original Vfs and restore after test
	origVfs := Vfs
	Vfs = memFs
	defer func() { Vfs = origVfs }()

	tests := []struct {
		name          string
		filename      string
		content       string
		repoName      string
		repoPath      string
		expectedTitle string
		expectedSlug  string
		wantErr       bool
	}{
		{
			name:     "basic markdown with frontmatter",
			filename: "/content/test-post.md",
			content: `---
title: My Test Post
slug: custom-slug
---

# Hello World

This is the content.`,
			repoName:      "blog",
			repoPath:      "/content",
			expectedTitle: "My Test Post",
			expectedSlug:  "custom-slug",
			wantErr:       false,
		},
		{
			name:     "no slug uses filename",
			filename: "/content/auto-slug-post.md",
			content: `---
title: Auto Slug Post
---

Content here.`,
			repoName:      "blog",
			repoPath:      "/content",
			expectedTitle: "Auto Slug Post",
			expectedSlug:  "auto-slug-post",
			wantErr:       false,
		},
		{
			name:     "no title uses filename",
			filename: "/content/no-title.md",
			content: `---
slug: has-slug
---

Just content.`,
			repoName:      "blog",
			repoPath:      "/content",
			expectedTitle: "no-title.md",
			expectedSlug:  "has-slug",
			wantErr:       false,
		},
		{
			name:     "with categories",
			filename: "/content/categorized.md",
			content: `---
title: Categorized Post
categories:
  - tech
  - golang
---

Content.`,
			repoName:      "blog",
			repoPath:      "/content",
			expectedTitle: "Categorized Post",
			expectedSlug:  "categorized",
			wantErr:       false,
		},
		{
			name:     "with tags instead of categories",
			filename: "/content/tagged.md",
			content: `---
title: Tagged Post
tags:
  - testing
  - unit-tests
---

Content.`,
			repoName:      "blog",
			repoPath:      "/content",
			expectedTitle: "Tagged Post",
			expectedSlug:  "tagged",
			wantErr:       false,
		},
		{
			name:     "with permalink instead of slug",
			filename: "/content/permalink-post.md",
			content: `---
title: Permalink Post
permalink: my-custom-permalink
---

Content.`,
			repoName:      "blog",
			repoPath:      "/content",
			expectedTitle: "Permalink Post",
			expectedSlug:  "my-custom-permalink",
			wantErr:       false,
		},
		{
			name:          "file too short",
			filename:      "/content/short.md",
			content:       "x",
			repoName:      "blog",
			repoPath:      "/content",
			expectedTitle: "",
			expectedSlug:  "",
			wantErr:       true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Write the test file
			err := afero.WriteFile(memFs, tt.filename, []byte(tt.content), 0644)
			if err != nil {
				t.Fatalf("Failed to create test file: %v", err)
			}

			item, err := LoadItem(tt.repoName, tt.repoPath, tt.filename)

			if tt.wantErr {
				if err == nil {
					t.Error("LoadItem should have returned an error")
				}
				return
			}

			if err != nil {
				t.Errorf("LoadItem returned unexpected error: %v", err)
				return
			}

			if item.Title != tt.expectedTitle {
				t.Errorf("Title = %q, want %q", item.Title, tt.expectedTitle)
			}

			if item.Slug != tt.expectedSlug {
				t.Errorf("Slug = %q, want %q", item.Slug, tt.expectedSlug)
			}

			if item.Repo != tt.repoName {
				t.Errorf("Repo = %q, want %q", item.Repo, tt.repoName)
			}

			if item.Source != tt.filename {
				t.Errorf("Source = %q, want %q", item.Source, tt.filename)
			}

			// Verify HTML was generated
			if item.Html == "" && !tt.wantErr {
				t.Error("HTML should be generated from markdown")
			}

			// Verify Raw content was set
			if item.Raw != tt.content {
				t.Errorf("Raw content mismatch")
			}
		})
	}
}

// TestLoadItem_HTMLRendering verifies the markdown to HTML conversion
func TestLoadItem_HTMLRendering(t *testing.T) {
	memFs := afero.NewMemMapFs()
	origVfs := Vfs
	Vfs = memFs
	defer func() { Vfs = origVfs }()

	content := `---
title: HTML Test
---

# Heading

**Bold** and *italic* text.

- List item 1
- List item 2
`
	afero.WriteFile(memFs, "/content/html-test.md", []byte(content), 0644)

	item, err := LoadItem("blog", "/content", "/content/html-test.md")
	if err != nil {
		t.Fatalf("LoadItem error: %v", err)
	}

	// Verify HTML contains expected elements
	if !strings.Contains(item.Html, "<h1") {
		t.Error("HTML should contain h1 heading")
	}
	if !strings.Contains(item.Html, "<strong>Bold</strong>") {
		t.Error("HTML should contain bold text")
	}
	if !strings.Contains(item.Html, "<em>italic</em>") {
		t.Error("HTML should contain italic text")
	}
	if !strings.Contains(item.Html, "<li>") {
		t.Error("HTML should contain list items")
	}
}

// TestLoadItem_SubdirectorySlug verifies slug generation for nested files
func TestLoadItem_SubdirectorySlug(t *testing.T) {
	memFs := afero.NewMemMapFs()
	origVfs := Vfs
	Vfs = memFs
	defer func() { Vfs = origVfs }()

	content := `---
title: Nested Post
---

Content.`
	afero.WriteFile(memFs, "/content/2024/01/nested-post.md", []byte(content), 0644)

	item, err := LoadItem("blog", "/content", "/content/2024/01/nested-post.md")
	if err != nil {
		t.Fatalf("LoadItem error: %v", err)
	}

	// Slug should include the subdirectory path
	if !strings.Contains(item.Slug, "2024") || !strings.Contains(item.Slug, "01") {
		t.Errorf("Slug should include subdirectory path, got %q", item.Slug)
	}
}
